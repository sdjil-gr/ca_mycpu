From da79a707d925dcd9f822ebe685004ebc945ad8ee Mon Sep 17 00:00:00 2001
From: Sun Guangrun <sunguangrun22@mails.ucas.ac.cn>
Date: Sun, 13 Oct 2024 19:44:54 +0800
Subject: [PATCH] finish exp13

---
 csr.v       | 302 ++++++++++++++++++++++++++++++++++++++++++++++
 csr.vh      |  72 +++++++++++
 mycpu_top.v | 335 +++++++++++++++++++++++++++++++++++++++-------------
 3 files changed, 629 insertions(+), 80 deletions(-)
 create mode 100644 csr.v
 create mode 100644 csr.vh

diff --git a/csr.v b/csr.v
new file mode 100644
index 0000000..9299ba4
--- /dev/null
+++ b/csr.v
@@ -0,0 +1,302 @@
+`include "csr.vh"
+module csr(
+    input  wire        clk,
+    input  wire        reset,
+
+    input  wire        csr_we,
+    input  wire        csr_re,
+    input  wire [13:0] csr_num,
+    input  wire [31:0] csr_wmask,
+    input  wire [31:0] csr_wvalue,
+    output wire [31:0] csr_rvalue,
+
+    input  wire        wb_ex,
+    input  wire        ertn_flush,
+    input  wire [ 5:0] wb_ecode,
+    input  wire [ 8:0] wb_esubcode,
+    input  wire [31:0] wb_pc,
+    input  wire [31:0] wb_vaddr,
+    output wire [31:0] ex_entry,
+    output wire [31:0] ex_epc,
+    output wire        has_int,
+    output wire [31:0] counter_id
+);
+
+//CSR寄存器
+//CRMD
+reg [ 1:0] csr_crmd_plv;
+reg        csr_crmd_ie;
+reg        csr_crmd_da;
+reg        csr_crmd_pg;
+reg [ 1:0] csr_crmd_datf;
+reg [ 1:0] csr_crmd_datm;
+//PRMD
+reg [ 1:0] csr_prmd_pplv;
+reg        csr_prmd_pie;
+//ECFG
+reg [12:0] csr_ecfg_lie;
+//ESTAT
+reg [12:0] csr_estat_is;
+reg [ 5:0] csr_estat_ecode;
+reg [ 8:0] csr_estat_esubcode;
+//ERA
+reg [31:0] csr_era_pc;
+//BADV
+reg [31:0] csr_badv_vaddr;
+//EENTRY
+reg [25:0] csr_eentry_va;
+//SAVE0~3
+reg [31:0] csr_save0;
+reg [31:0] csr_save1;
+reg [31:0] csr_save2;
+reg [31:0] csr_save3;
+//TID
+reg [31:0] csr_tid_tid;
+//TCFG
+reg        csr_tcfg_en;
+reg        csr_tcfg_periodic;
+reg [29:0] csr_tcfg_initval;
+//TVAL
+wire [31:0] csr_tval_timeval;
+//TICLR
+wire       csr_ticlr_clr;
+
+//timer
+reg [31:0] timer_cnt;
+wire [31:0] tcfg_next_value;
+
+wire [31:0] csr_crmd_rvalue;
+wire [31:0] csr_prmd_rvalue;
+wire [31:0] csr_ecfg_rvalue;
+wire [31:0] csr_estat_rvalue;
+wire [31:0] csr_era_rvalue;
+wire [31:0] csr_badv_rvalue;
+wire [31:0] csr_eentry_rvalue;
+wire [31:0] csr_tid_rvalue;
+wire [31:0] csr_tcfg_rvalue;
+wire [31:0] csr_tval_rvalue;
+wire [31:0] csr_ticlr_rvalue;
+
+assign csr_crmd_rvalue = {23'b0,csr_crmd_datm,csr_crmd_datf,csr_crmd_pg,csr_crmd_da,csr_crmd_ie,csr_crmd_plv};
+assign csr_prmd_rvalue = {29'b0,csr_prmd_pie,csr_prmd_pplv};
+assign csr_ecfg_rvalue = {19'b0,csr_ecfg_lie};
+assign csr_estat_rvalue = {1'b0,csr_estat_esubcode,csr_estat_ecode,3'b0,csr_estat_is[12:11],1'b0,csr_estat_is[9:0]};
+assign csr_era_rvalue = csr_era_pc;
+assign csr_badv_rvalue = csr_badv_vaddr;
+assign csr_eentry_rvalue = {csr_eentry_va,6'b0};
+assign csr_tid_rvalue = csr_tid_tid;
+assign csr_tcfg_rvalue = {csr_tcfg_initval,csr_tcfg_periodic,csr_tcfg_en};
+assign csr_tval_rvalue = csr_tval_timeval;
+assign csr_ticlr_rvalue = {31'b0,csr_ticlr_clr};
+
+assign csr_rvalue =     csr_num == `CSR_CRMD   ? csr_crmd_rvalue :
+                        csr_num == `CSR_PRMD   ? csr_prmd_rvalue :
+                        csr_num == `CSR_ECFG   ? csr_ecfg_rvalue :
+                        csr_num == `CSR_ESTAT  ? csr_estat_rvalue :
+                        csr_num == `CSR_ERA    ? csr_era_rvalue :
+                        csr_num == `CSR_BADV   ? csr_badv_rvalue :
+                        csr_num == `CSR_EENTRY ? csr_eentry_rvalue :
+                        csr_num == `CSR_SAVE0  ? csr_save0 :
+                        csr_num == `CSR_SAVE1  ? csr_save1 :
+                        csr_num == `CSR_SAVE2  ? csr_save2 :
+                        csr_num == `CSR_SAVE3  ? csr_save3 : 
+                        csr_num == `CSR_TID    ? csr_tid_rvalue :
+                        csr_num == `CSR_TCFG   ? csr_tcfg_rvalue :
+                        csr_num == `CSR_TVAL   ? csr_tval_rvalue :
+                        csr_num == `CSR_TICLR  ? csr_ticlr_rvalue :
+                        32'b0;
+assign ex_entry = csr_eentry_rvalue;
+assign ex_epc = csr_era_rvalue;
+assign has_int = (csr_estat_is[12:0] & csr_ecfg_lie[12:0])!= 13'b0 && csr_crmd_ie;
+assign counter_id = csr_tid_tid;
+
+//CRMD 的 PLV 域以及 IE 域
+always @(posedge clk) begin
+    if (reset) begin
+        csr_crmd_plv <= 2'b00;
+        csr_crmd_ie  <= 1'b0;
+    end
+    else if(wb_ex)begin
+        csr_crmd_plv <= 2'b00;
+        csr_crmd_ie <= 1'b0;
+    end
+    else if(ertn_flush) begin
+        csr_crmd_plv <= csr_prmd_pplv;
+        csr_crmd_ie <= csr_prmd_pie;
+    end
+    else if(csr_we && csr_num == `CSR_CRMD)  begin
+        csr_crmd_plv <= csr_wmask[`CSR_CRMD_PLV] & csr_wvalue[`CSR_CRMD_PLV]
+                    |  ~csr_wmask[`CSR_CRMD_PLV] & csr_crmd_plv;
+        csr_crmd_ie  <= csr_wmask[`CSR_CRMD_IE] & csr_wvalue[`CSR_CRMD_IE]
+                    |  ~csr_wmask[`CSR_CRMD_IE] & csr_crmd_ie;
+    end
+end
+
+//CRMD 的DA、PG、DATF、DATM 域
+always @(posedge clk) begin
+    if (reset) begin
+        csr_crmd_da <= 1'b1;
+        csr_crmd_pg <= 1'b0;
+        csr_crmd_datf <= 2'b00;
+        csr_crmd_datm <= 2'b00;
+    end
+end
+
+//PRMD 的 PPLV 域以及 PIE 域
+always @(posedge clk) begin
+    if(wb_ex)begin
+        csr_prmd_pplv <= csr_crmd_plv;
+        csr_prmd_pie <= csr_crmd_ie;
+    end
+    else if(csr_we && csr_num==`CSR_PRMD) begin
+        csr_prmd_pplv <= csr_wmask[`CSR_PRMD_PPLV] & csr_wvalue[`CSR_PRMD_PPLV]
+                    |   ~csr_wmask[`CSR_PRMD_PPLV] & csr_prmd_pplv;
+        csr_prmd_pie  <= csr_wmask[`CSR_PRMD_PIE] & csr_wvalue[`CSR_PRMD_PIE]
+                    |   ~csr_wmask[`CSR_PRMD_PIE] & csr_prmd_pie;
+    end
+end
+
+//ECFG 的 LIE 域
+always @(posedge clk) begin
+    if(reset)begin
+        csr_ecfg_lie <= 13'b0;
+    end
+    else if(csr_we && csr_num==`CSR_ECFG)begin
+         csr_ecfg_lie <= csr_wmask[`CSR_ECFG_LIE] & 13'h1bff & csr_wvalue[`CSR_ECFG_LIE]
+                    |   ~csr_wmask[`CSR_ECFG_LIE] & 13'h1bff & csr_ecfg_lie;
+    end
+end
+
+//ESTAT 的 IS 域
+always @(posedge clk) begin
+    if(reset)begin
+        csr_estat_is[1:0] <= 2'b0;
+    end
+    else if(csr_we && csr_num==`CSR_ESTAT) begin
+        csr_estat_is[1:0] <= csr_wmask[`CSR_ESTAT_IS10] & csr_wvalue[`CSR_ESTAT_IS10]
+                        |   ~csr_wmask[`CSR_ESTAT_IS10] & csr_estat_is[1:0];
+    end
+    csr_estat_is[9:2] <= 8'b0;
+    csr_estat_is[10] <= 1'b0;
+    
+    if(timer_cnt == 32'b0) begin
+        csr_estat_is[11] <= 1'b1;
+    end
+    else if(csr_we && csr_num==`CSR_TICLR && csr_wmask[`CSR_TICLR_CLR] && csr_wvalue[`CSR_TICLR_CLR]) begin
+        csr_estat_is[11] <= 1'b0;
+    end
+
+    csr_estat_is[12] <= 1'b0;
+end
+
+//ESTAT 的 ECODE 域以及 ESUBCODE 域
+always @(posedge clk) begin
+    if(wb_ex)begin
+        csr_estat_ecode <= wb_ecode;
+        csr_estat_esubcode <= wb_esubcode;
+    end
+end
+
+//ERA 的 PC 域
+always @(posedge clk) begin
+    if(wb_ex)begin
+        csr_era_pc <= wb_pc;
+    end
+    else if(csr_we && csr_num==`CSR_ERA) begin
+        csr_era_pc <= csr_wmask[`CSR_ERA_PC] & csr_wvalue[`CSR_ERA_PC]
+                  |  ~csr_wmask[`CSR_ERA_PC] & csr_era_pc;
+    end
+end
+
+//BADV 的 VADDR 域
+always @(posedge clk) begin
+    if(wb_ex && (wb_ecode==`ECODE_ADE || wb_ecode==`ECODE_ALE))begin
+        csr_badv_vaddr <= (wb_ecode==`ECODE_ADE && wb_esubcode==`ESUBCODE_ADEF) ? wb_pc :
+                           wb_vaddr;
+    end
+end
+
+//EENTRY 的 VA 域
+always @(posedge clk) begin
+    if(csr_we && csr_num==`CSR_EENTRY) begin
+        csr_eentry_va <= csr_wmask[`CSR_EENTRY_VA] & csr_wvalue[`CSR_EENTRY_VA]
+                    |   ~csr_wmask[`CSR_EENTRY_VA] & csr_eentry_va;
+    end
+end
+
+//SAVE0~3 的数据域
+always @(posedge clk) begin
+    if(csr_we && csr_num==`CSR_SAVE0) begin
+        csr_save0 <= csr_wmask[`CSR_SAVE0_DATA] & csr_wvalue[`CSR_SAVE0_DATA]
+                  |  ~csr_wmask[`CSR_SAVE0_DATA] & csr_save0;
+    end
+    else if(csr_we && csr_num==`CSR_SAVE1) begin
+        csr_save1 <= csr_wmask[`CSR_SAVE1_DATA] & csr_wvalue[`CSR_SAVE1_DATA]
+                  |  ~csr_wmask[`CSR_SAVE1_DATA] & csr_save1;
+    end
+    else if(csr_we && csr_num==`CSR_SAVE2) begin
+        csr_save2 <= csr_wmask[`CSR_SAVE2_DATA] & csr_wvalue[`CSR_SAVE2_DATA]
+                  |  ~csr_wmask[`CSR_SAVE2_DATA] & csr_save2;
+    end
+    else if(csr_we && csr_num==`CSR_SAVE3) begin
+        csr_save3 <= csr_wmask[`CSR_SAVE3_DATA] & csr_wvalue[`CSR_SAVE3_DATA]
+                  |  ~csr_wmask[`CSR_SAVE3_DATA] & csr_save3;
+    end
+end
+
+//TID 的数据域
+always @(posedge clk) begin
+    if(reset) begin
+        csr_tid_tid <= 32'b0;
+    end
+    else if(csr_we && csr_num==`CSR_TID) begin
+        csr_tid_tid <= csr_wmask[`CSR_TID_TID] & csr_wvalue[`CSR_TID_TID]
+                |    ~ csr_wmask[`CSR_TID_TID] & csr_tid_tid;
+    end
+end
+
+//TCFG 的 EN、PERIODIC、INITVAL 域
+always @(posedge clk) begin
+    if(reset) begin
+        csr_tcfg_en <= 1'b0;
+    end
+    else if(csr_we && csr_num==`CSR_TCFG) begin
+        csr_tcfg_en <= csr_wmask[`CSR_TCFG_EN] & csr_wvalue[`CSR_TCFG_EN]
+                |    ~ csr_wmask[`CSR_TCFG_EN] & csr_tcfg_en;
+    end
+
+    if (csr_we && csr_num==`CSR_TCFG) begin
+        csr_tcfg_periodic <= csr_wmask[`CSR_TCFG_PERIODIC] & csr_wvalue[`CSR_TCFG_PERIODIC]
+                        |   ~csr_wmask[`CSR_TCFG_PERIODIC] & csr_tcfg_periodic;
+        csr_tcfg_initval <= csr_wmask[`CSR_TCFG_INITVAL] & csr_wvalue[`CSR_TCFG_INITVAL]
+                        |  ~csr_wmask[`CSR_TCFG_INITVAL] & csr_tcfg_initval;
+    end
+end
+
+//TVAL 的 TIMEVAL 域
+assign csr_tval_timeval = timer_cnt[31:0];
+
+//定时器
+assign tcfg_next_value = csr_wmask[31:0] & csr_wvalue[31:0] 
+                    |   ~csr_wmask[31:0] & csr_tcfg_rvalue;
+always @(posedge clk) begin
+    if(reset) begin
+        timer_cnt <= 32'hffffffff;
+    end
+    else if(csr_we && csr_num==`CSR_TCFG && tcfg_next_value[`CSR_TCFG_EN]) begin
+        timer_cnt <= {tcfg_next_value[`CSR_TCFG_INITVAL], 2'b0};
+    end
+    else if(csr_tcfg_en && timer_cnt != 32'hffffffff) begin
+        if(timer_cnt == 32'b0 && csr_tcfg_periodic) begin
+            timer_cnt <= {csr_tcfg_initval, 2'b0};
+        end
+        else begin
+            timer_cnt <= timer_cnt - 1'b1;
+        end
+    end
+end
+
+//TICLR 的 CLR 域
+assign csr_ticlr_clr = 1'b0;
+
+endmodule
\ No newline at end of file
diff --git a/csr.vh b/csr.vh
new file mode 100644
index 0000000..d84778c
--- /dev/null
+++ b/csr.vh
@@ -0,0 +1,72 @@
+`define CSR_CRMD 13'h0
+`define CSR_PRMD 13'h1
+`define CSR_ECFG 13'h4
+`define CSR_ESTAT 13'h5
+`define CSR_ERA 13'h6
+`define CSR_BADV 13'h7
+`define CSR_EENTRY 13'hc
+`define CSR_SAVE0 13'h30
+`define CSR_SAVE1 13'h31
+`define CSR_SAVE2 13'h32
+`define CSR_SAVE3 13'h33
+`define CSR_TID 13'h40
+`define CSR_TCFG 13'h41
+`define CSR_TVAL 13'h42
+`define CSR_TICLR 13'h44
+
+`define CSR_CRMD_PLV 1:0
+`define CSR_CRMD_IE  2
+`define CSR_CRMD_DA  3
+`define CSR_CRMD_PG  4
+`define CSR_CRMD_DATF 6:5
+`define CSR_CRMD_DATM 8:7
+
+`define CSR_PRMD_PPLV 1:0
+`define CSR_PRMD_PIE  2
+
+`define CSR_ECFG_LIE 12:0
+
+`define CSR_ESTAT_IS10 1:0
+`define CSR_ESTAT_ECODE 21:16
+`define CSR_ESTAT_ESUBCODE 30:22
+
+`define CSR_ERA_PC 31:0
+
+`define CSR_BADV_VADDR 31:0
+
+`define CSR_EENTRY_VA 31:6
+
+`define CSR_SAVE0_DATA 31:0
+`define CSR_SAVE1_DATA 31:0
+`define CSR_SAVE2_DATA 31:0
+`define CSR_SAVE3_DATA 31:0
+
+`define CSR_TID_TID 31:0
+
+`define CSR_TCFG_EN 0
+`define CSR_TCFG_PERIODIC 1
+`define CSR_TCFG_INITVAL 31:2
+
+`define CSR_TVAL_TIMEVAL 31:0
+
+`define CSR_TICLR_CLR 0
+
+
+
+
+`define ECODE_INT 6'h0
+`define ECODE_PIL 6'h1
+`define ECODE_PIS 6'h2
+`define ECODE_PIF 6'h3
+`define ECODE_PME 6'h4
+`define ECODE_PPI 6'h7
+`define ECODE_ADE 6'h8
+`define ECODE_ALE 6'h9
+`define ECODE_SYS 6'hb
+`define ECODE_BRK 6'hc
+`define ECODE_INE 6'hd
+`define ECODE_IPE 6'he
+`define ECODE_TLBR 6'h3f
+
+`define ESUBCODE_ADEF 9'h0
+`define ESUBCODE_ADEM 9'h1
\ No newline at end of file
diff --git a/mycpu_top.v b/mycpu_top.v
index c9877a5..e0ab5fe 100644
--- a/mycpu_top.v
+++ b/mycpu_top.v
@@ -1,3 +1,4 @@
+`include "csr.vh"
 module mycpu_top(
     input  wire        clk,
     input  wire        resetn,
@@ -37,7 +38,8 @@ end
 
 wire [31:0] seq_pc;
 wire [31:0] nextpc;
-wire        br_taken;
+wire        br_taken_ID;
+wire        br_taken_EX;
 wire [31:0] br_target;
 wire [31:0] inst;
 reg  [31:0] pc;
@@ -48,6 +50,7 @@ wire        src1_is_pc;
 wire        src2_is_imm;
 wire        res_from_mem;
 wire        dst_is_r1;
+wire        dst_is_rj;
 wire        gr_we;
 wire        src_reg_is_rd;
 wire [4: 0] dest;
@@ -94,6 +97,16 @@ wire [15:0] op_25_22_d;
 wire [ 3:0] op_21_20_d;
 wire [31:0] op_19_15_d;
 
+wire [1:0]  op_25_24;
+wire [4:0]  op_14_10;
+wire [4:0]  op_9_5;
+wire [4:0]  op_4_0;
+
+wire [3:0]   op_25_24_d;
+wire [31:0]   op_14_10_d;
+wire [31:0]   op_9_5_d;
+wire [31:0]   op_4_0_d;
+
 wire        inst_add_w;
 wire        inst_sub_w;
 wire        inst_slt;
@@ -144,8 +157,44 @@ wire        inst_blt;
 wire        inst_bge;
 wire        inst_bltu;
 wire        inst_bgeu;
-
-
+//异常指令
+wire        inst_csrrd;
+wire        inst_csrwr;
+wire        inst_csrxchg;
+wire        inst_ertn;
+wire        inst_syscall;
+wire        inst_break;
+//rdcnt指令
+wire        inst_rdcntvl_w;
+wire        inst_rdcntvh_w;
+wire        inst_rdcntid_w;
+
+//异常触发信号
+wire        exc_at_ID;       //在ID阶段发生异常 
+wire        exc_at_EX;       //在EX阶段发生异常
+wire        exc_adef;        //取指地址异常
+wire        exc_ale;         //地址非对齐异常
+wire        exc_ine;         //指令不存在异常
+wire        exc_break;       //断点异常
+wire        exc_syscall;     //系统调用异常
+
+//csr指令接口
+wire csr_we;
+wire csr_re;
+wire [13:0] csr_num;
+wire [31:0] csr_wmask;
+wire [31:0] csr_wvalue;
+wire [31:0] csr_rvalue;
+//csr其他接口
+wire        wb_ex;
+wire [31:0] wb_pc;
+wire        ertn_flush;
+wire [ 5:0] wb_ecode;
+wire [ 8:0] wb_esubcode;
+wire [31:0] ex_entry;
+wire [31:0] ex_epc;
+wire        has_int;
+wire [31:0] counter_id;
 
 wire        need_ui5;
 wire        need_si12;
@@ -181,7 +230,7 @@ wire [ 3:0] data_sram_we_ID;
 wire [31:0] data_sram_addr_EX;
 wire [ 1:0] data_sram_addroffset;
 wire [31:0] data_sram_wdata_ID;
-wire [ 2:0] data_sram_ld_tag;
+wire [ 3:0] data_sram_type_tag;
 wire [31:0] data_sram_rdata_off;
 
 //流水级间的寄存器
@@ -200,9 +249,9 @@ reg [ 3:0] data_sram_we_MEM;
 reg [31:0] data_sram_addr_MEM;
 reg [31:0] data_sram_wdata_EX;
 reg [31:0] data_sram_wdata_MEM;
-reg [ 2:0] data_sram_ld_tag_EX;
-reg [ 2:0] data_sram_ld_tag_MEM;
-reg [ 2:0] data_sram_ld_tag_WB;
+reg [ 3:0] data_sram_type_tag_EX;
+reg [ 3:0] data_sram_type_tag_MEM;
+reg [ 3:0] data_sram_type_tag_WB;
 reg [ 1:0] data_sram_addroffset_WB;
 reg        res_from_mem_EX;
 reg        res_from_mem_MEM;
@@ -214,12 +263,13 @@ reg [ 4:0] dest_WB;
 reg        gr_we_EX;
 reg        gr_we_MEM;
 reg        gr_we_WB;
+reg        is_csr_EX;
+reg [31:0] csr_rvalue_EX;
+reg        is_rdcntid_EX;
+reg        is_rdcntvl_EX;
+reg        is_rdcntvh_EX;
 
 //添加握手信号
-reg IF_valid;
-wire IF_allowin;
-wire IF_readygo;
-
 reg ID_valid;
 wire ID_allowin;
 wire ID_readygo;
@@ -238,42 +288,38 @@ wire WB_readygo;
 
 //握手信号处理
 /****************************************************************************/
-assign IF_readygo = valid_r ? !hit_wait : 1'b1;//访存前递阻塞
-assign ID_readygo = !need_div_r;//阻塞除法
-assign EX_readygo = 1'b1;
+assign ID_readygo = valid_r ? !hit_wait : 1'b1;//访存前递阻塞
+assign EX_readygo = !need_div_r;//阻塞除法
 assign MEM_readygo = 1'b1;
 assign WB_readygo = 1'b1;
 
-assign IF_allowin = (!IF_valid  || ID_allowin  && IF_readygo )&&valid;
-assign ID_allowin = (!ID_valid  || EX_allowin  && ID_readygo )&&valid;
-assign EX_allowin = (!EX_valid  || MEM_allowin && EX_readygo )&&valid;
-assign MEM_allowin =(!MEM_valid || WB_allowin  && MEM_readygo)&&valid;
-assign WB_allowin = (!WB_valid  ||                WB_readygo )&&valid;
+assign ID_allowin  = (!ID_valid  || EX_allowin  && ID_readygo )&&valid;
+assign EX_allowin  = (!EX_valid  || MEM_allowin && EX_readygo )&&valid;
+assign MEM_allowin = (!MEM_valid || WB_allowin  && MEM_readygo)&&valid;
+assign WB_allowin  = (!WB_valid  ||                WB_readygo )&&valid;
 
 //流水级控制
 always @(posedge clk) begin
     if (reset)
-		IF_valid <= 1'b0;
-    else if (br_taken && IF_allowin)//分支跳转则把预取的错误指令取消
-        IF_valid <= 1'b0;
-	else if(IF_allowin)
-		IF_valid <= 1'b1;
-end
-always @(posedge clk) begin
-	if (reset)
 		ID_valid <= 1'b0;
+    else if ((br_taken_ID || br_taken_EX) && ID_allowin)//分支跳转则把预取的错误指令取消
+        ID_valid <= 1'b0;
 	else if(ID_allowin)
-		ID_valid <= IF_valid && IF_readygo;
+		ID_valid <= 1'b1;
 end
 always @(posedge clk) begin
 	if (reset)
 		EX_valid <= 1'b0;
+    else if((br_taken_EX || exc_ine) && EX_allowin )//EX跳转或者无效指令则取消
+		EX_valid <= 1'b0;
 	else if(EX_allowin)
 		EX_valid <= ID_valid && ID_readygo;
 end
 always @(posedge clk) begin
 	if (reset)
 		MEM_valid <= 1'b0;
+    else if(exc_ale && MEM_allowin)//地址非对齐异常则取消该访存指令
+		MEM_valid <= 1'b0;
 	else if(MEM_allowin)
 		MEM_valid <= EX_valid && EX_readygo;
 end
@@ -286,50 +332,132 @@ end
 /****************************************************************************/
 
 
+//计时器
+/****************************************************************************/
+reg  [63:0] stable_counter;
+wire [31:0] counter_vl;
+wire [31:0] counter_vh;
+
+always @(posedge clk) begin
+    if (reset)
+        stable_counter <= 64'h0;
+    else 
+        stable_counter <= stable_counter + 64'h1;
+end
+
+assign counter_vl = stable_counter[31:0];
+assign counter_vh = stable_counter[63:32];
+/****************************************************************************/
+
 //PC值处理
 /****************************************************************************/
 assign seq_pc       = pc + 3'h4;
-assign nextpc       = valid_r ? (br_taken ? br_target : seq_pc) : seq_pc;
+assign nextpc       = valid_r ? (br_taken_ID || br_taken_EX ? br_target : seq_pc) : seq_pc;
 
 //依次传递pc值，以便最后对比信号
 always @(posedge clk) begin
     if (reset) begin
         pc <= 32'h1c000000;     //trick: to make nextpc be 0x1c000000 during reset 
     end
-    else if(IF_allowin)begin
+    else if(ID_allowin)begin
         pc <= nextpc;
     end
 end
 always @(posedge clk) begin
     if (reset)
         pc_ID <= 32'h1bfffffc;
-    else if(IF_allowin)
+    else if(ID_allowin)
         pc_ID <= pc;
 end
 always @(posedge clk) begin
     if (reset)
         pc_EX <= 32'h1bfffffc;
-    else if(ID_allowin && IF_valid && IF_readygo)
+    else if(EX_allowin && ID_valid && ID_readygo)
         pc_EX <= pc_ID;
 end
 always @(posedge clk) begin
     if (reset)
         pc_MEM <= 32'h1bfffffc;
-    else if(EX_allowin && ID_valid && ID_readygo)
+    else if(MEM_allowin && EX_valid && EX_readygo)
         pc_MEM <= pc_EX;
 end
 always @(posedge clk) begin
     if (reset)
         pc_WB <= 32'h1bfffffc;
-    else if(MEM_allowin && EX_valid && EX_readygo)
+    else if(WB_allowin && MEM_valid && MEM_readygo)
         pc_WB <= pc_MEM;
 end
 /****************************************************************************/
 
 
+//异常处理及控制状态寄存器
+/****************************************************************************/
+assign csr_re = (inst_csrrd || inst_csrwr || inst_csrxchg) && ID_valid;
+assign csr_we = (inst_csrwr || inst_csrxchg) && ID_valid;
+assign csr_wmask = (inst_csrwr)? 32'hffffffff :
+                    (inst_csrxchg)? rj_value : 32'h00000000;
+assign csr_wvalue = rkd_value;
+
+//异常判断
+assign exc_adef = pc[1:0] != 2'b00;
+assign exc_ale  = (data_sram_type_tag_EX[2] && data_sram_addr_EX[0] != 1'b0
+                || data_sram_type_tag_EX[1] && data_sram_addr_EX[1:0] != 2'b0) && EX_valid;
+assign exc_ine = ~(inst_add_w | inst_sub_w | inst_slt | inst_sltu | inst_nor | inst_and | inst_or | inst_xor 
+                 | inst_slli_w | inst_srli_w | inst_srai_w | inst_addi_w | inst_ld_w | inst_st_w 
+                 | inst_jirl | inst_b | inst_bl | inst_beq | inst_bne | inst_lu12i_w 
+                 | inst_slti | inst_sltiu | inst_andi | inst_ori | inst_xori | inst_sll_w | inst_srl_w | inst_sra_w | inst_pcaddu12i 
+                 | inst_mul_w | inst_mulh_w | inst_mulh_wu | inst_div_w | inst_mod_w | inst_div_wu | inst_mod_wu 
+                 | inst_ld_b | inst_ld_h | inst_ld_bu | inst_ld_hu | inst_st_b | inst_st_h 
+                 | inst_blt | inst_bge | inst_bltu | inst_bgeu 
+                 | inst_csrrd | inst_csrwr | inst_csrxchg 
+                 | inst_ertn | inst_syscall | inst_break
+                 | inst_rdcntvl_w | inst_rdcntvh_w | inst_rdcntid_w) && ID_valid;
+assign exc_break = inst_break && ID_valid;
+assign exc_syscall = inst_syscall && ID_valid;
+
+assign exc_at_ID = exc_break || exc_syscall || exc_adef || exc_ine;
+assign exc_at_EX = exc_ale;
+
+assign wb_ex = exc_at_ID || exc_at_EX || has_int;
+assign wb_pc = (exc_adef) ? pc :
+               (!br_taken_EX && ID_valid) ? pc_ID :
+                pc_EX;
+assign ertn_flush = inst_ertn && ID_valid;
+assign wb_ecode = has_int     ? `ECODE_INT :
+                  exc_adef    ? `ECODE_ADE :
+                  exc_ale     ? `ECODE_ALE : 
+                  exc_syscall ? `ECODE_SYS :
+                  exc_break   ? `ECODE_BRK : 
+                  exc_ine     ? `ECODE_INE :
+                  6'h0;
+assign wb_esubcode = 9'h0;
+
+csr u_csr(
+    .clk(clk),
+    .reset(reset),
+    .csr_we(csr_we),
+    .csr_re(csr_re),
+    .csr_num(csr_num),
+    .csr_wmask(csr_wmask),
+    .csr_wvalue(csr_wvalue),
+    .csr_rvalue(csr_rvalue),
+    .wb_ex(wb_ex),
+    .ertn_flush(ertn_flush),
+    .wb_ecode(wb_ecode),
+    .wb_esubcode(wb_esubcode),
+    .wb_pc(wb_pc),
+    .wb_vaddr(data_sram_addr_EX),
+    .ex_entry(ex_entry),
+    .ex_epc(ex_epc),
+    .has_int(has_int),
+    .counter_id(counter_id)
+);
+/****************************************************************************/
+
+
 //IF流水级
 /****************************************************************************/
-assign inst_sram_en    = IF_allowin;
+assign inst_sram_en    = ID_allowin && !exc_adef;//取值地址异常时不进行取指
 assign inst_sram_we    = 4'b0;
 assign inst_sram_addr  = pc;
 assign inst_sram_wdata = 32'b0;
@@ -353,6 +481,13 @@ assign op_25_22  = inst[25:22];
 assign op_21_20  = inst[21:20];
 assign op_19_15  = inst[19:15];
 
+assign op_25_24  = inst[25:24];
+assign op_14_10  = inst[14:10];
+assign op_9_5    = inst[9:5];
+assign op_4_0    = inst[4:0];
+
+assign csr_num   = inst[23:10];
+
 assign rd   = inst[ 4: 0];
 assign rj   = inst[ 9: 5];
 assign rk   = inst[14:10];
@@ -366,6 +501,10 @@ decoder_6_64 u_dec0(.in(op_31_26 ), .out(op_31_26_d ));
 decoder_4_16 u_dec1(.in(op_25_22 ), .out(op_25_22_d ));
 decoder_2_4  u_dec2(.in(op_21_20 ), .out(op_21_20_d ));
 decoder_5_32 u_dec3(.in(op_19_15 ), .out(op_19_15_d ));
+decoder_2_4  u_dec4(.in(op_25_24 ), .out(op_25_24_d ));
+decoder_5_32 u_dec5(.in(op_14_10 ), .out(op_14_10_d ));
+decoder_5_32 u_dec6(.in(op_9_5   ), .out(op_9_5_d   ));
+decoder_5_32 u_dec7(.in(op_4_0   ), .out(op_4_0_d   ));
 
 assign inst_add_w  = op_31_26_d[6'h00] & op_25_22_d[4'h0] & op_21_20_d[2'h1] & op_19_15_d[5'h00];
 assign inst_sub_w  = op_31_26_d[6'h00] & op_25_22_d[4'h0] & op_21_20_d[2'h1] & op_19_15_d[5'h02];
@@ -417,7 +556,18 @@ assign inst_blt     = op_31_26_d[6'h18];
 assign inst_bge     = op_31_26_d[6'h19];
 assign inst_bltu    = op_31_26_d[6'h1a];
 assign inst_bgeu    = op_31_26_d[6'h1b];
-
+//新添加CSR指令有效信号
+assign inst_csrrd   = op_31_26_d[6'h01] & op_25_24_d[2'h0] & op_9_5_d[5'h0];
+assign inst_csrwr   = op_31_26_d[6'h01] & op_25_24_d[2'h0] & op_9_5_d[5'h1];
+assign inst_csrxchg = op_31_26_d[6'h01] & op_25_24_d[2'h0] & ~op_9_5_d[5'h0] & ~op_9_5_d[5'h1];
+//新添加异常指令有效信号
+assign inst_ertn    = op_31_26_d[6'h1] & op_25_22_d[4'h9] & op_21_20_d[2'h0] & op_19_15_d[5'h10] & op_14_10_d[5'h0e];
+assign inst_syscall = op_31_26_d[6'h0] & op_25_22_d[4'h0] & op_21_20_d[2'h2] & op_19_15_d[5'h16];
+assign inst_break   = op_31_26_d[6'h0] & op_25_22_d[4'h0] & op_21_20_d[2'h2] & op_19_15_d[5'h14];
+//新添加rdcnt指令有效信号
+assign inst_rdcntvl_w = op_31_26_d[6'h0] & op_25_22_d[4'h0] & op_21_20_d[2'h0] & op_19_15_d[5'h0] & op_14_10_d[5'h18] & op_9_5_d[5'h0];
+assign inst_rdcntvh_w = op_31_26_d[6'h0] & op_25_22_d[4'h0] & op_21_20_d[2'h0] & op_19_15_d[5'h0] & op_14_10_d[5'h19] & op_9_5_d[5'h0];
+assign inst_rdcntid_w = op_31_26_d[6'h0] & op_25_22_d[4'h0] & op_21_20_d[2'h0] & op_19_15_d[5'h0] & op_14_10_d[5'h18] & op_4_0_d[5'h0];
 
 assign alu_op[ 0] = inst_add_w | inst_addi_w | inst_ld_b | inst_ld_h | inst_ld_bu | inst_ld_hu | inst_ld_w 
                     | inst_st_b | inst_st_h | inst_st_w | inst_jirl | inst_bl | inst_pcaddu12i;
@@ -450,11 +600,11 @@ assign src2_is_4  =  inst_jirl | inst_bl;
 assign need_rj    =  ~(inst_b | inst_bl | inst_lu12i_w);
 assign need_rk    =  inst_add_w | inst_sub_w | inst_slt | inst_sltu | inst_and | inst_or | inst_nor | inst_xor | inst_sll_w | inst_srl_w | inst_sra_w |
                 inst_mul_w | inst_mulh_w | inst_mulh_wu | inst_div_w | inst_mod_w | inst_div_wu | inst_mod_wu; 
-assign need_rd    =  inst_beq | inst_bne | inst_st_b | inst_st_h | inst_st_w | inst_blt | inst_bge | inst_bltu | inst_bgeu;
+assign need_rd    =  inst_beq | inst_bne | inst_st_b | inst_st_h | inst_st_w | inst_blt | inst_bge | inst_bltu | inst_bgeu | inst_csrwr | inst_csrxchg;
 
-assign dest_EX_ID = dest_EX & {5{gr_we_EX}} & {5{ID_valid}};
-assign dest_MEM_ID = dest_MEM & {5{gr_we_MEM}} & {5{EX_valid}};
-assign dest_WB_ID = dest_WB & {5{gr_we_WB}} & {5{MEM_valid}};
+assign dest_EX_ID = dest_EX & {5{gr_we_EX}} & {5{EX_valid}};
+assign dest_MEM_ID = dest_MEM & {5{gr_we_MEM}} & {5{MEM_valid}};
+assign dest_WB_ID = dest_WB & {5{gr_we_WB}} & {5{WB_valid}};
 
 assign rj_hit = need_rj && (rj != 5'd0) && ((rj == dest_EX_ID) || (rj == dest_MEM_ID) || (rj == dest_WB_ID));
 assign rk_hit = need_rk && (rk != 5'd0) && ((rk == dest_EX_ID) || (rk == dest_MEM_ID) || (rk == dest_WB_ID));
@@ -490,7 +640,7 @@ assign br_offs = need_si26 ? {{ 4{i26[25]}}, i26[25:0], 2'b0} :
 
 assign jirl_offs = {{14{i16[15]}}, i16[15:0], 2'b0};
 
-assign src_reg_is_rd = inst_beq | inst_bne | inst_st_b | inst_st_h | inst_st_w | inst_blt | inst_bge | inst_bltu | inst_bgeu;
+assign src_reg_is_rd = inst_beq | inst_bne | inst_st_b | inst_st_h | inst_st_w | inst_blt | inst_bge | inst_bltu | inst_bgeu | inst_csrwr | inst_csrxchg;
 
 assign src1_is_pc    = inst_jirl | inst_bl | inst_pcaddu12i;
 
@@ -518,8 +668,11 @@ assign src2_is_imm   = inst_slli_w |
 
 assign res_from_mem  = inst_ld_b | inst_ld_h | inst_ld_bu | inst_ld_hu | inst_ld_w;
 assign dst_is_r1     = inst_bl;
-assign gr_we         = ~inst_st_b & ~inst_st_h & ~inst_st_w & ~inst_beq & ~inst_bne & ~inst_b & ~inst_blt & ~inst_bge & ~inst_bltu & ~inst_bgeu;
-assign dest          = dst_is_r1 ? 5'd1 : rd;
+assign dst_is_rj     = inst_rdcntid_w;
+assign gr_we         = ~inst_st_b & ~inst_st_h & ~inst_st_w & ~inst_beq & ~inst_bne & ~inst_b & ~inst_blt & ~inst_bge & ~inst_bltu & ~inst_bgeu & ~inst_ertn & ~inst_syscall;
+assign dest          = dst_is_r1 ? 5'd1 :
+                       dst_is_rj ? rj :
+                       rd;
 
 
 /******** 寄存器读取块 ********/
@@ -544,14 +697,14 @@ assign rkd_value = src_reg_is_rd && rd_hit ? rd_pro :
 
 
 /******** 分支判断块 ********/
-
 assign rj_sign = {{rj_value[31] & ~inst_bltu & ~inst_bgeu}, rj_value};
 assign rd_sign = {{rkd_value[31] & ~inst_bltu & ~inst_bgeu}, rkd_value};
 
 assign rj_lt_rd = $signed(rj_sign) < $signed(rd_sign);
 
 assign rj_eq_rd = (rj_value == rkd_value);
-assign br_taken = (   inst_beq  &&  rj_eq_rd
+// - 将跳转分为在ID的跳转以及在EX的跳转，EX的跳转相比ID的跳转额外取消一条错取指令
+assign br_taken_ID = (   inst_beq  &&  rj_eq_rd
                    || inst_bne  && !rj_eq_rd
                    || inst_blt  &&  rj_lt_rd
                    || inst_bge  &&  !rj_lt_rd
@@ -560,9 +713,14 @@ assign br_taken = (   inst_beq  &&  rj_eq_rd
                    || inst_jirl
                    || inst_bl
                    || inst_b
-                  ) && IF_valid;
-assign br_target = (inst_beq || inst_bne || inst_bl || inst_b || inst_blt || inst_bge || inst_bltu || inst_bgeu) ? (pc_ID + br_offs) :
-                                                   /*inst_jirl*/ (rj_value + jirl_offs);
+                   || inst_ertn
+                   ) && ID_valid || exc_at_ID || has_int;
+assign br_taken_EX = exc_at_EX;
+// - 调整了一下br_target的优先级
+assign br_target =  (wb_ex) ? ex_entry :
+                    (inst_ertn) ? ex_epc :
+                    (inst_jirl) ? (rj_value + jirl_offs) :
+                    (pc_ID + br_offs);//branch
 /******** 分支判断块 ********/
 
 
@@ -578,7 +736,7 @@ assign data_sram_we_ID    = {4{inst_st_w}} | {2'b00, {2{inst_st_h}}} | {3'b000,
 assign data_sram_wdata_ID = inst_st_b ? {4{rkd_value[ 7:0]}} :
                             inst_st_h ? {2{rkd_value[15:0]}} :
                             rkd_value;
-assign data_sram_ld_tag = {{inst_ld_b | inst_ld_bu}, {inst_ld_h | inst_ld_hu}, {inst_ld_bu | inst_ld_hu}};// {byte_en, half_en, unsigned_en}
+assign data_sram_type_tag = {{inst_ld_b | inst_ld_bu | inst_st_b}, {inst_ld_h | inst_ld_hu | inst_st_h}, {inst_st_w | inst_ld_w}, {inst_ld_bu | inst_ld_hu}};// {byte_en, half_en, unsigned_en}
 
 //将alu及除法器输入保存到EX阶段并使用
 always @(posedge clk) begin
@@ -590,7 +748,7 @@ always @(posedge clk) begin
         div_unsigned_r <= 1'b0;
         get_div_or_mod_r <= 1'b0;
     end
-    else if(IF_valid && ID_allowin && IF_readygo)begin
+    else if(ID_valid && EX_allowin && ID_readygo)begin
         alu_src1_r <= alu_src1;
         alu_src2_r <= alu_src2;
         alu_op_r   <= alu_op;
@@ -600,13 +758,29 @@ always @(posedge clk) begin
     end
 end
 //将一些后续控制信号从ID阶段传递下去
+always @(posedge clk) begin //寄存器控制
+    if(reset) begin
+        is_csr_EX <= 1'b0;
+        csr_rvalue_EX <= 32'h0;
+        is_rdcntid_EX <= 1'b0;
+        is_rdcntvl_EX <= 1'b0;
+        is_rdcntvh_EX <= 1'b0;
+    end
+    else if(EX_allowin && ID_valid && ID_readygo) begin
+        is_csr_EX <= csr_re;
+        csr_rvalue_EX <= csr_rvalue;
+        is_rdcntid_EX <= inst_rdcntid_w;
+        is_rdcntvl_EX <= inst_rdcntvl_w;
+        is_rdcntvh_EX <= inst_rdcntvh_w;
+    end
+end
 always @(posedge clk) begin //寄存器控制
     if(reset) begin
         res_from_mem_EX <= 1'b0;
         dest_EX <= 5'd0;
         gr_we_EX <= 1'b0;
     end
-    else if(ID_allowin && IF_valid && IF_readygo) begin
+    else if(EX_allowin && ID_valid && ID_readygo) begin
         res_from_mem_EX <= res_from_mem;
         dest_EX <= dest;
         gr_we_EX <= gr_we;
@@ -617,13 +791,13 @@ always @(posedge clk) begin //访存控制
         data_sram_en_EX <= 1'b0;
         data_sram_we_EX <= 4'b0;
         data_sram_wdata_EX <= 32'h0;
-        data_sram_ld_tag_EX <= 3'b0;
+        data_sram_type_tag_EX <= 4'b0;
     end
-    else if(IF_valid && ID_allowin && IF_readygo) begin
+    else if(ID_valid && EX_allowin && ID_readygo) begin
         data_sram_en_EX <= data_sram_en_ID;
         data_sram_we_EX <= data_sram_we_ID;
         data_sram_wdata_EX <= data_sram_wdata_ID;
-        data_sram_ld_tag_EX <= data_sram_ld_tag;
+        data_sram_type_tag_EX <= data_sram_type_tag;
     end
 end
 /****************************************************************************/
@@ -650,27 +824,28 @@ always @(posedge clk) begin
         udiv_sor_valid <= 1'b0;
         udiv_dend_valid <= 1'b0;
     end
-    else if(IF_valid && ID_allowin && IF_readygo) begin
+    else if(ID_valid && EX_allowin && ID_readygo) begin
         sdiv_sor_valid <= div_signed;
         sdiv_dend_valid <= div_signed;
         udiv_sor_valid <= div_unsigned;
         udiv_dend_valid <= div_unsigned;
     end
-    if (sdiv_sor_ready || sdiv_dend_ready) begin
-        sdiv_sor_valid <= !sdiv_sor_ready && sdiv_sor_valid;
-        sdiv_dend_valid <= !sdiv_dend_ready && sdiv_dend_valid;
-    end
-    if (udiv_sor_ready || udiv_dend_ready) begin
-        udiv_sor_valid <= !udiv_sor_ready && udiv_sor_valid;
-        udiv_dend_valid <= !udiv_dend_ready && udiv_dend_valid;
+    else begin //除法器的bug修复(与prj4无关)
+        if (sdiv_sor_ready || sdiv_dend_ready) begin
+            sdiv_sor_valid <= !sdiv_sor_ready && sdiv_sor_valid;
+            sdiv_dend_valid <= !sdiv_dend_ready && sdiv_dend_valid;
+        end
+        if (udiv_sor_ready || udiv_dend_ready) begin
+            udiv_sor_valid <= !udiv_sor_ready && udiv_sor_valid;
+            udiv_dend_valid <= !udiv_dend_ready && udiv_dend_valid;
+        end
     end
-
 end
 always @(posedge clk) begin
     if(reset) begin
         need_div_r <= 1'b0;
     end
-    else if(IF_valid && ID_allowin && IF_readygo) begin
+    else if(ID_valid && EX_allowin && ID_readygo) begin
         need_div_r <= need_div;
     end
     else if (sdiv_out_valid || udiv_out_valid)  begin
@@ -682,10 +857,6 @@ end
 
 //EX流水级
 /****************************************************************************/
-
-
-
-
 alu u_alu(// alu进行运算
     .alu_op     (alu_op_r    ),
     .alu_src1   (alu_src1_r  ),
@@ -719,6 +890,10 @@ div_gen_unsigned u_div_gen_unsigned(// 进行无符号除法运算
 
 assign EX_final_result =  div_signed_r ? (get_div_or_mod_r ? sdiv_result[63:32] : sdiv_result[31:0]):
                           div_unsigned_r ? (get_div_or_mod_r ? udiv_result[63:32] : udiv_result[31:0]):
+                          (is_csr_EX)?csr_rvalue_EX://csr指令直接从csr中取值
+                          (is_rdcntid_EX)?counter_id:
+                          (is_rdcntvl_EX)?counter_vl:
+                          (is_rdcntvh_EX)?counter_vh:
                           alu_result;
 assign data_sram_addr_EX  = EX_final_result;//设计访存地址
 
@@ -729,14 +904,14 @@ always @(posedge clk) begin//访存控制
         data_sram_we_MEM <= 4'b0;
         data_sram_addr_MEM <= 32'h0;
         data_sram_wdata_MEM <= 32'h0;
-        data_sram_ld_tag_MEM <= 3'b0;
+        data_sram_type_tag_MEM <= 4'b0;
     end
-    else if(EX_allowin && ID_valid && ID_readygo) begin
+    else if(MEM_allowin && EX_valid && EX_readygo) begin
         data_sram_en_MEM <= data_sram_en_EX;
         data_sram_we_MEM <= (data_sram_we_EX << alu_result[1:0]);
         data_sram_addr_MEM <= data_sram_addr_EX;
         data_sram_wdata_MEM <= data_sram_wdata_EX;
-        data_sram_ld_tag_MEM <= data_sram_ld_tag_EX;
+        data_sram_type_tag_MEM <= data_sram_type_tag_EX;
     end
 end
 always @(posedge clk) begin//寄存器控制
@@ -745,7 +920,7 @@ always @(posedge clk) begin//寄存器控制
         dest_MEM <= 5'd0;
         gr_we_MEM <= 1'b0;
     end
-    else if(EX_allowin && ID_valid && ID_readygo) begin
+    else if(MEM_allowin && EX_valid && EX_readygo) begin
         res_from_mem_MEM <= res_from_mem_EX;
         dest_MEM <= dest_EX;
         gr_we_MEM <= gr_we_EX;
@@ -757,7 +932,7 @@ end
 
 //EX --> MEM
 
-// data_sram_en_MEM, data_sram_we_MEM, data_sram_addr_MEM, data_sram_wdata_MEM, data_sram_ld_tag_MEM      访存相关信号
+// data_sram_en_MEM, data_sram_we_MEM, data_sram_addr_MEM, data_sram_wdata_MEM, data_sram_type_tag_MEM      访存相关信号
 // res_from_mem_MEM, dest_MEM, gr_we_MEM      寄存器相关信号
 // PC_MEM
 
@@ -766,7 +941,7 @@ end
 //MEM流水级
 /****************************************************************************/
 //设置访存信号
-assign data_sram_en = data_sram_en_MEM;
+assign data_sram_en = data_sram_en_MEM & MEM_valid & MEM_readygo; // - 小补丁，防止后续埋雷
 assign data_sram_we = data_sram_we_MEM;
 assign data_sram_addr = {data_sram_addr_MEM[31:2], 2'b00};//对齐地址
 assign data_sram_addroffset = data_sram_addr_MEM[1:0];//访存偏移
@@ -779,22 +954,22 @@ always @(posedge clk) begin
         res_from_mem_WB <= 1'b0;
         dest_WB <= 5'd0;
         gr_we_WB <= 1'b0;
-        data_sram_ld_tag_WB <= 3'b0;
+        data_sram_type_tag_WB <= 4'b0;
         data_sram_addroffset_WB <= 2'b0;
     end
-    else if(MEM_allowin && EX_valid && EX_readygo) begin
+    else if(WB_allowin && MEM_valid && MEM_readygo) begin
         alu_result_WB <= data_sram_addr_MEM;
         res_from_mem_WB <= res_from_mem_MEM;
         dest_WB <= dest_MEM;
         gr_we_WB <= gr_we_MEM;
-        data_sram_ld_tag_WB <= data_sram_ld_tag_MEM;
+        data_sram_type_tag_WB <= data_sram_type_tag_MEM;
         data_sram_addroffset_WB <= data_sram_addroffset;
     end
 end
 
 assign data_sram_rdata_off = data_sram_rdata >> (data_sram_addroffset_WB * 8);
-assign mem_result   = data_sram_ld_tag_WB[2]? {{24{data_sram_rdata_off[7] & ~data_sram_ld_tag_WB[0]}}, data_sram_rdata_off[7:0]} :
-                      data_sram_ld_tag_WB[1]? {{16{data_sram_rdata_off[15] & ~data_sram_ld_tag_WB[0]}}, data_sram_rdata_off[15:0]} :
+assign mem_result   = data_sram_type_tag_WB[3]? {{24{data_sram_rdata_off[7] & ~data_sram_type_tag_WB[0]}}, data_sram_rdata_off[7:0]} :
+                      data_sram_type_tag_WB[2]? {{16{data_sram_rdata_off[15] & ~data_sram_type_tag_WB[0]}}, data_sram_rdata_off[15:0]} :
                       data_sram_rdata_off;
 /****************************************************************************/
 
@@ -811,7 +986,7 @@ assign mem_result   = data_sram_ld_tag_WB[2]? {{24{data_sram_rdata_off[7] & ~dat
 /****************************************************************************/
 assign final_result = res_from_mem_WB ? mem_result : alu_result_WB; // 最终写回数据
 
-assign rf_we    = gr_we_WB && MEM_valid && MEM_readygo;
+assign rf_we    = gr_we_WB && WB_valid && WB_readygo;
 assign rf_waddr = dest_WB;
 assign rf_wdata = final_result;
 /****************************************************************************/
-- 
2.44.0.windows.1

