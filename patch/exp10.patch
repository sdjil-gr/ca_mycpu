From 644acd5c2647a45a56ad551083cee4394db819b3 Mon Sep 17 00:00:00 2001
From: Sun Guangrun <sunguangrun22@mails.ucas.ac.cn>
Date: Sun, 29 Sep 2024 00:29:15 +0800
Subject: [PATCH] finish exp10

---
 alu.v       |  19 ++-
 mycpu_top.v | 382 ++++++++++++++++++++++++++++++++++++++++------------
 2 files changed, 310 insertions(+), 91 deletions(-)

diff --git a/alu.v b/alu.v
index fb7fe59..b770c29 100644
--- a/alu.v
+++ b/alu.v
@@ -1,5 +1,5 @@
 module alu(
-  input  wire [11:0] alu_op,
+  input  wire [14:0] alu_op,
   input  wire [31:0] alu_src1,
   input  wire [31:0] alu_src2,
   output wire [31:0] alu_result
@@ -17,6 +17,9 @@ wire op_sll;   //logic left shift
 wire op_srl;   //logic right shift
 wire op_sra;   //arithmetic right shift
 wire op_lui;   //Load Upper Immediate
+wire op_mul;   // multiplication and get low
+wire op_mulh;  // signed multiplication and get high
+wire op_mulhu; // unsigned multiplication and get high
 
 // control code decomposition
 assign op_add  = alu_op[ 0];
@@ -31,6 +34,9 @@ assign op_sll  = alu_op[ 8];
 assign op_srl  = alu_op[ 9];
 assign op_sra  = alu_op[10];
 assign op_lui  = alu_op[11];
+assign op_mul  = alu_op[12];
+assign op_mulh = alu_op[13];
+assign op_mulhu= alu_op[14];
 
 wire [31:0] add_sub_result;
 wire [31:0] slt_result;
@@ -84,6 +90,13 @@ assign sr64_result = {{32{op_sra & alu_src1[31]}}, alu_src1[31:0]} >> alu_src2[4
 
 assign sr_result   = sr64_result[31:0];
 
+// MUL result
+wire [32:0] mul_a, mul_b;
+wire [65:0] mul_result;
+assign mul_a = {alu_src1[31]&&!op_mulhu,alu_src1};
+assign mul_b = {alu_src2[31]&&!op_mulhu,alu_src2};
+assign mul_result = $signed(mul_a) * $signed(mul_b);
+
 // final result mux
 assign alu_result = ({32{op_add|op_sub}} & add_sub_result)
                   | ({32{op_slt       }} & slt_result)
@@ -94,6 +107,8 @@ assign alu_result = ({32{op_add|op_sub}} & add_sub_result)
                   | ({32{op_xor       }} & xor_result)
                   | ({32{op_lui       }} & lui_result)
                   | ({32{op_sll       }} & sll_result)
-                  | ({32{op_srl|op_sra}} & sr_result);
+                  | ({32{op_srl|op_sra}} & sr_result)
+                  | ({32{op_mul       }} & mul_result[31:0])
+                  | ({32{op_mulh|op_mulhu}} & mul_result[63:32]);
 
 endmodule
diff --git a/mycpu_top.v b/mycpu_top.v
index 1cc1b1b..b7e434a 100644
--- a/mycpu_top.v
+++ b/mycpu_top.v
@@ -42,7 +42,7 @@ wire [31:0] br_target;
 wire [31:0] inst;
 reg  [31:0] pc;
 
-wire [11:0] alu_op;
+wire [14:0] alu_op;
 wire        load_op;
 wire        src1_is_pc;
 wire        src2_is_imm;
@@ -111,9 +111,20 @@ wire        inst_bl;
 wire        inst_beq;
 wire        inst_bne;
 wire        inst_lu12i_w;
+//新添加指令
+wire        inst_slti;
+wire        inst_sltiu;
+wire        inst_andi;
+wire        inst_ori;
+wire        inst_xori;
+wire        inst_sll_w;
+wire        inst_srl_w;
+wire        inst_sra_w;
+wire        inst_pcaddu12i;
 
 wire        need_ui5;
 wire        need_si12;
+wire        need_ui12;
 wire        need_si16;
 wire        need_si20;
 wire        need_si26;
@@ -130,6 +141,13 @@ wire [31:0] rf_wdata;
 wire [31:0] alu_src1   ;
 wire [31:0] alu_src2   ;
 wire [31:0] alu_result ;
+wire        need_div;
+wire        div_unsigned;
+wire        div_signed;
+wire        get_div_or_mod;
+wire [63:0] sdiv_result;
+wire [63:0] udiv_result;
+wire [31:0] EX_final_result;
 wire [31:0] final_result;
 wire [31:0] mem_result;
 
@@ -142,7 +160,11 @@ wire [31:0] data_sram_wdata_ID;
 reg [31:0] pc_ID, pc_EX, pc_MEM, pc_WB;
 reg [31:0] alu_src1_r;
 reg [31:0] alu_src2_r;
-reg [11:0] alu_op_r;
+reg [14:0] alu_op_r;
+reg        need_div_r;
+reg        div_unsigned_r;
+reg        div_signed_r;
+reg        get_div_or_mod_r;
 reg        data_sram_en_EX;
 reg        data_sram_en_MEM;
 reg [ 3:0] data_sram_we_EX;
@@ -161,9 +183,6 @@ reg        gr_we_EX;
 reg        gr_we_MEM;
 reg        gr_we_WB;
 
-
-
-
 //添加握手信号
 reg IF_valid;
 wire IF_allowin;
@@ -185,9 +204,10 @@ reg WB_valid;
 wire WB_allowin;
 wire WB_readygo;
 
-//考虑冲突
-assign IF_readygo = valid_r ? !hit_wait : 1'b1;
-assign ID_readygo = 1'b1;
+//握手信号处理
+/****************************************************************************/
+assign IF_readygo = valid_r ? !hit_wait : 1'b1;//访存前递阻塞
+assign ID_readygo = !need_div_r;//阻塞除法
 assign EX_readygo = 1'b1;
 assign MEM_readygo = 1'b1;
 assign WB_readygo = 1'b1;
@@ -202,7 +222,7 @@ assign WB_allowin = (!WB_valid  ||                WB_readygo )&&valid;
 always @(posedge clk) begin
     if (reset)
 		IF_valid <= 1'b0;
-    else if (br_taken && IF_allowin)
+    else if (br_taken && IF_allowin)//分支跳转则把预取的错误指令取消
         IF_valid <= 1'b0;
 	else if(IF_allowin)
 		IF_valid <= 1'b1;
@@ -231,15 +251,18 @@ always @(posedge clk) begin
 	else if(WB_allowin)
 		WB_valid <= MEM_valid && MEM_readygo;
 end
+/****************************************************************************/
 
+
+//PC值处理
+/****************************************************************************/
 assign seq_pc       = pc + 3'h4;
 assign nextpc       = valid_r ? (br_taken ? br_target : seq_pc) : seq_pc;
 
-
 //依次传递pc值，以便最后对比信号
 always @(posedge clk) begin
     if (reset) begin
-        pc <= 32'h1bfffffc;     //trick: to make nextpc be 0x1c000000 during reset 
+        pc <= 32'h1c000000;     //trick: to make nextpc be 0x1c000000 during reset 
     end
     else if(IF_allowin)begin
         pc <= nextpc;
@@ -269,14 +292,30 @@ always @(posedge clk) begin
     else if(MEM_allowin && EX_valid && EX_readygo)
         pc_WB <= pc_MEM;
 end
+/****************************************************************************/
 
 
+//IF流水级
+/****************************************************************************/
 assign inst_sram_en    = IF_allowin;
 assign inst_sram_we    = 4'b0;
 assign inst_sram_addr  = pc;
 assign inst_sram_wdata = 32'b0;
 assign inst = inst_sram_rdata;
+/****************************************************************************/
+
+
+
+// IF  --->  ID
+
+// inst      指令
+// PC_ID
+
 
+
+//ID流水级
+/****************************************************************************/
+//译码
 assign op_31_26  = inst[31:26];
 assign op_25_22  = inst[25:22];
 assign op_21_20  = inst[21:20];
@@ -316,30 +355,55 @@ assign inst_bl     = op_31_26_d[6'h15];
 assign inst_beq    = op_31_26_d[6'h16];
 assign inst_bne    = op_31_26_d[6'h17];
 assign inst_lu12i_w= op_31_26_d[6'h05] & ~inst[25];
+//新添加算术逻辑运算指令有效信号
+assign inst_slti     = op_31_26_d[6'h00] & op_25_22_d[4'h8];
+assign inst_sltiu    = op_31_26_d[6'h00] & op_25_22_d[4'h9];
+assign inst_andi     = op_31_26_d[6'h00] & op_25_22_d[4'hd];
+assign inst_ori      = op_31_26_d[6'h00] & op_25_22_d[4'he];
+assign inst_xori     = op_31_26_d[6'h00] & op_25_22_d[4'hf];
+assign inst_sll_w    = op_31_26_d[6'h00] & op_25_22_d[4'h0] & op_21_20_d[2'h1] & op_19_15_d[5'h0e];
+assign inst_srl_w    = op_31_26_d[6'h00] & op_25_22_d[4'h0] & op_21_20_d[2'h1] & op_19_15_d[5'h0f];
+assign inst_sra_w    = op_31_26_d[6'h00] & op_25_22_d[4'h0] & op_21_20_d[2'h1] & op_19_15_d[5'h10];
+assign inst_pcaddu12i= op_31_26_d[6'h07] & ~inst[25];
+//新添加乘除运算指令有效信号
+assign inst_mul_w    = op_31_26_d[6'h00] & op_25_22_d[4'h0] & op_21_20_d[2'h1] & op_19_15_d[5'h18];
+assign inst_mulh_w   = op_31_26_d[6'h00] & op_25_22_d[4'h0] & op_21_20_d[2'h1] & op_19_15_d[5'h19];
+assign inst_mulh_wu  = op_31_26_d[6'h00] & op_25_22_d[4'h0] & op_21_20_d[2'h1] & op_19_15_d[5'h1a];
+assign inst_div_w    = op_31_26_d[6'h00] & op_25_22_d[4'h0] & op_21_20_d[2'h2] & op_19_15_d[5'h00];
+assign inst_mod_w    = op_31_26_d[6'h00] & op_25_22_d[4'h0] & op_21_20_d[2'h2] & op_19_15_d[5'h01];
+assign inst_div_wu   = op_31_26_d[6'h00] & op_25_22_d[4'h0] & op_21_20_d[2'h2] & op_19_15_d[5'h02];
+assign inst_mod_wu   = op_31_26_d[6'h00] & op_25_22_d[4'h0] & op_21_20_d[2'h2] & op_19_15_d[5'h03];
 
 assign alu_op[ 0] = inst_add_w | inst_addi_w | inst_ld_w | inst_st_w
-                    | inst_jirl | inst_bl;
+                    | inst_jirl | inst_bl|inst_pcaddu12i;
 assign alu_op[ 1] = inst_sub_w;
-assign alu_op[ 2] = inst_slt;
-assign alu_op[ 3] = inst_sltu;
-assign alu_op[ 4] = inst_and;
+assign alu_op[ 2] = inst_slt|inst_slti;
+assign alu_op[ 3] = inst_sltu|inst_sltiu;
+assign alu_op[ 4] = inst_and|inst_andi;
 assign alu_op[ 5] = inst_nor;
-assign alu_op[ 6] = inst_or;
-assign alu_op[ 7] = inst_xor;
-assign alu_op[ 8] = inst_slli_w;
-assign alu_op[ 9] = inst_srli_w;
-assign alu_op[10] = inst_srai_w;
+assign alu_op[ 6] = inst_or|inst_ori;
+assign alu_op[ 7] = inst_xor|inst_xori;
+assign alu_op[ 8] = inst_slli_w|inst_sll_w;
+assign alu_op[ 9] = inst_srli_w|inst_srl_w;
+assign alu_op[10] = inst_srai_w|inst_sra_w;
 assign alu_op[11] = inst_lu12i_w;
+assign alu_op[12] = inst_mul_w;
+assign alu_op[13] = inst_mulh_w;
+assign alu_op[14] = inst_mulh_wu;
 
 assign need_ui5   =  inst_slli_w | inst_srli_w | inst_srai_w;
-assign need_si12  =  inst_addi_w | inst_ld_w | inst_st_w;
+assign need_si12  =  inst_addi_w | inst_ld_w | inst_st_w|inst_slti | inst_sltiu;//改动
+assign need_ui12  =  inst_andi | inst_ori | inst_xori;
 assign need_si16  =  inst_jirl | inst_beq | inst_bne;
-assign need_si20  =  inst_lu12i_w;
+assign need_si20  =  inst_lu12i_w|inst_pcaddu12i;
 assign need_si26  =  inst_b | inst_bl;
 assign src2_is_4  =  inst_jirl | inst_bl;
 
+
+/******** 前递块 ********/
 assign need_rj    =  ~(inst_b | inst_bl | inst_lu12i_w);
-assign need_rk    =  inst_add_w | inst_sub_w | inst_slt | inst_sltu | inst_and | inst_or |inst_nor | inst_xor;
+assign need_rk    =  inst_add_w | inst_sub_w | inst_slt | inst_sltu | inst_and | inst_or | inst_nor | inst_xor | inst_sll_w | inst_srl_w | inst_sra_w |
+                inst_mul_w | inst_mulh_w | inst_mulh_wu | inst_div_w | inst_mod_w | inst_div_wu | inst_mod_wu; 
 assign need_rd    =  inst_beq | inst_bne | inst_st_w;
 
 assign dest_EX_ID = dest_EX & {5{gr_we_EX}} & {5{ID_valid}};
@@ -354,23 +418,26 @@ assign reg_EX_hit = need_rj && (rj != 5'd0) && (rj == dest_EX_ID) || need_rk &&
 assign reg_MEM_hit = need_rj && (rj != 5'd0) && (rj == dest_MEM_ID) || need_rk && (rk != 5'd0) && (rk == dest_MEM_ID) || need_rd && (rd != 5'd0) && (rd == dest_MEM_ID);
 assign reg_WB_hit = need_rj && (rj != 5'd0) && (rj == dest_WB_ID) || need_rk && (rk != 5'd0) && (rk == dest_WB_ID) || need_rd && (rd != 5'd0) && (rd == dest_WB_ID);
 
-assign rj_pro = (rj == dest_EX_ID) ? alu_result :
+assign rj_pro = (rj == dest_EX_ID) ? EX_final_result :
                 (rj == dest_MEM_ID) ? data_sram_addr_MEM :
                 final_result ;
 
-assign rk_pro = (rk == dest_EX_ID) ? alu_result :
+assign rk_pro = (rk == dest_EX_ID) ? EX_final_result :
                 (rk == dest_MEM_ID) ? data_sram_addr_MEM :
                 final_result ;
 
-assign rd_pro = (rd == dest_EX_ID) ? alu_result :
+assign rd_pro = (rd == dest_EX_ID) ? EX_final_result :
                 (rd == dest_MEM_ID) ? data_sram_addr_MEM :
                 final_result ;
 
 assign hit_wait = reg_EX_hit && data_sram_en_EX || reg_MEM_hit && data_sram_en_MEM;
+/******** 前递块 ********/
+
 
 assign imm = src2_is_4 ? 32'h4                      :
              need_si20 ? {i20[19:0], 12'b0}         :
-/*need_ui5 || need_si12*/{{20{i12[11]}}, i12[11:0]} ;
+             need_ui12 ? {{20{1'b0}}, i12[11:0]} :
+/*need_ui5 || need_si12*/{{20{i12[11]}}, i12[11:0]} ;//gaidong
 
 assign br_offs = need_si26 ? {{ 4{i26[25]}}, i26[25:0], 2'b0} :
                              {{14{i16[15]}}, i16[15:0], 2'b0} ;
@@ -379,7 +446,7 @@ assign jirl_offs = {{14{i16[15]}}, i16[15:0], 2'b0};
 
 assign src_reg_is_rd = inst_beq | inst_bne | inst_st_w;
 
-assign src1_is_pc    = inst_jirl | inst_bl;
+assign src1_is_pc    = inst_jirl | inst_bl|inst_pcaddu12i;
 
 assign src2_is_imm   = inst_slli_w |
                        inst_srli_w |
@@ -389,7 +456,13 @@ assign src2_is_imm   = inst_slli_w |
                        inst_st_w   |
                        inst_lu12i_w|
                        inst_jirl   |
-                       inst_bl     ;
+                       inst_bl     |
+                       inst_slti   |
+                       inst_sltiu  |
+                       inst_andi   |
+                       inst_ori    |
+                       inst_xori   |
+                       inst_pcaddu12i;
 
 assign res_from_mem  = inst_ld_w;
 assign dst_is_r1     = inst_bl;
@@ -397,48 +470,8 @@ assign gr_we         = ~inst_st_w & ~inst_beq & ~inst_bne & ~inst_b;
 assign mem_we        = inst_st_w;
 assign dest          = dst_is_r1 ? 5'd1 : rd;
 
-//将一些后续控制信号从ID阶段传递下去
-always @(posedge clk) begin
-    if(reset) begin
-        res_from_mem_EX <= 1'b0;
-        dest_EX <= 5'd0;
-        gr_we_EX <= 1'b0;
-    end
-    else if(ID_allowin && IF_valid && IF_readygo) begin
-        res_from_mem_EX <= res_from_mem;
-        dest_EX <= dest;
-        gr_we_EX <= gr_we;
-    end
-end
-always @(posedge clk) begin
-    if(reset) begin
-        res_from_mem_MEM <= 1'b0;
-        dest_MEM <= 5'd0;
-        gr_we_MEM <= 1'b0;
-    end
-    else if(EX_allowin && ID_valid && ID_readygo) begin
-        res_from_mem_MEM <= res_from_mem_EX;
-        dest_MEM <= dest_EX;
-        gr_we_MEM <= gr_we_EX;
-    end
-end
-always @(posedge clk) begin
-    if(reset) begin
-        alu_result_WB <= 32'h0;
-        res_from_mem_WB <= 1'b0;
-        dest_WB <= 5'd0;
-        gr_we_WB <= 1'b0;
-    end
-    else if(MEM_allowin && EX_valid && EX_readygo) begin
-        alu_result_WB <= data_sram_addr_MEM;
-        res_from_mem_WB <= res_from_mem_MEM;
-        dest_WB <= dest_MEM;
-        gr_we_WB <= gr_we_MEM;
-    end
-end
-
-
 
+/******** 寄存器读取块 ********/
 assign rf_raddr1 = rj;
 assign rf_raddr2 = src_reg_is_rd ? rd :rk;
 regfile u_regfile(
@@ -456,7 +489,10 @@ assign rj_value  = rj_hit ? rj_pro : rf_rdata1;
 assign rkd_value = src_reg_is_rd && rd_hit ? rd_pro :
                   !src_reg_is_rd && rk_hit ? rk_pro :
                   rf_rdata2;
+/******** 寄存器读取块 ********/
+
 
+/******** 分支判断块 ********/
 assign rj_eq_rd = (rj_value == rkd_value);
 assign br_taken = (   inst_beq  &&  rj_eq_rd
                    || inst_bne  && !rj_eq_rd
@@ -466,39 +502,53 @@ assign br_taken = (   inst_beq  &&  rj_eq_rd
                   ) && IF_valid;
 assign br_target = (inst_beq || inst_bne || inst_bl || inst_b) ? (pc_ID + br_offs) :
                                                    /*inst_jirl*/ (rj_value + jirl_offs);
+/******** 分支判断块 ********/
 
 
 assign alu_src1 = src1_is_pc  ? pc_ID[31:0] : rj_value;
 assign alu_src2 = src2_is_imm ? imm : rkd_value;
+assign need_div = inst_div_w | inst_mod_w | inst_div_wu | inst_mod_wu; 
+assign div_signed = inst_div_w | inst_mod_w;
+assign div_unsigned = inst_div_wu | inst_mod_wu;
+assign get_div_or_mod = inst_div_w | inst_div_wu;
 
-//将alu输入保存到EX阶段并使用
+assign data_sram_en_ID    = inst_ld_w || inst_st_w;
+assign data_sram_we_ID    = {4{mem_we && valid}};
+assign data_sram_wdata_ID = rkd_value;
+
+//将alu及除法器输入保存到EX阶段并使用
 always @(posedge clk) begin
     if(reset) begin
         alu_src1_r <= 32'h0;
         alu_src2_r <= 32'h0;
-        alu_op_r   <= 12'h0;
+        alu_op_r   <= 15'h0;
+        div_signed_r <= 1'b0;
+        div_unsigned_r <= 1'b0;
+        get_div_or_mod_r <= 1'b0;
     end
     else if(IF_valid && ID_allowin && IF_readygo)begin
         alu_src1_r <= alu_src1;
         alu_src2_r <= alu_src2;
         alu_op_r   <= alu_op;
+        div_signed_r <= div_signed;
+        div_unsigned_r <= div_unsigned;
+        get_div_or_mod_r <= get_div_or_mod;
     end
 end
-
-alu u_alu(
-    .alu_op     (alu_op_r    ),
-    .alu_src1   (alu_src1_r  ),
-    .alu_src2   (alu_src2_r  ),
-    .alu_result (alu_result)
-    );
-
-//传递访存控制信号
-assign data_sram_en_ID    = inst_ld_w || inst_st_w;
-assign data_sram_we_ID    = {4{mem_we && valid}};
-assign data_sram_addr_EX  = alu_result;
-assign data_sram_wdata_ID = rkd_value;
-
-always @(posedge clk) begin
+//将一些后续控制信号从ID阶段传递下去
+always @(posedge clk) begin //寄存器控制
+    if(reset) begin
+        res_from_mem_EX <= 1'b0;
+        dest_EX <= 5'd0;
+        gr_we_EX <= 1'b0;
+    end
+    else if(ID_allowin && IF_valid && IF_readygo) begin
+        res_from_mem_EX <= res_from_mem;
+        dest_EX <= dest;
+        gr_we_EX <= gr_we;
+    end
+end
+always @(posedge clk) begin //访存控制
     if(reset) begin
         data_sram_en_EX <= 1'b0;
         data_sram_we_EX <= 4'b0;
@@ -510,7 +560,104 @@ always @(posedge clk) begin
         data_sram_wdata_EX <= data_sram_wdata_ID;
     end
 end
+/****************************************************************************/
+
+
+//ID --> EX
+
+// alu_src1_r, alu_src2_r, alu_op_r      alu相关信号
+// res_from_mem_EX, dest_EX, gr_we_EX      寄存器相关信号
+// data_sram_en_EX, data_sram_we_EX, data_sram_wdata_EX      访存相关信号
+// sdiv_sor_valid, sdiv_dend_valid, need_div_r      除法器相关信号
+// PC_EX
+
+
+/********除法器模块********/
+reg  sdiv_sor_valid, sdiv_dend_valid;
+wire sdiv_sor_ready, sdiv_dend_ready, sdiv_out_valid;
+reg  udiv_sor_valid, udiv_dend_valid;
+wire udiv_sor_ready, udiv_dend_ready, udiv_out_valid;
+always @(posedge clk) begin
+    if(reset) begin
+        sdiv_sor_valid <= 1'b0;
+        sdiv_dend_valid <= 1'b0;
+        udiv_sor_valid <= 1'b0;
+        udiv_dend_valid <= 1'b0;
+    end
+    else if(IF_valid && ID_allowin && IF_readygo) begin
+        sdiv_sor_valid <= div_signed;
+        sdiv_dend_valid <= div_signed;
+        udiv_sor_valid <= div_unsigned;
+        udiv_dend_valid <= div_unsigned;
+    end
+    if (sdiv_sor_ready || sdiv_dend_ready) begin
+        sdiv_sor_valid <= !sdiv_sor_ready && sdiv_sor_valid;
+        sdiv_dend_valid <= !sdiv_dend_ready && sdiv_dend_valid;
+    end
+    if (udiv_sor_ready || udiv_dend_ready) begin
+        udiv_sor_valid <= !udiv_sor_ready && udiv_sor_valid;
+        udiv_dend_valid <= !udiv_dend_ready && udiv_dend_valid;
+    end
+
+end
 always @(posedge clk) begin
+    if(reset) begin
+        need_div_r <= 1'b0;
+    end
+    else if(IF_valid && ID_allowin && IF_readygo) begin
+        need_div_r <= need_div;
+    end
+    else if (sdiv_out_valid || udiv_out_valid)  begin
+        need_div_r <= 1'b0;
+    end
+end
+/********除法器模块********/
+
+
+//EX流水级
+/****************************************************************************/
+
+
+
+
+alu u_alu(// alu进行运算
+    .alu_op     (alu_op_r    ),
+    .alu_src1   (alu_src1_r  ),
+    .alu_src2   (alu_src2_r  ),
+    .alu_result (alu_result)
+    );
+
+div_gen_signed u_div_gen_signed(// 进行符号除法运算
+    .aclk                   (clk         ),
+    .s_axis_divisor_tdata   (alu_src2_r  ),
+    .s_axis_divisor_tvalid  (sdiv_sor_valid),
+    .s_axis_divisor_tready  (sdiv_sor_ready),
+    .s_axis_dividend_tdata  (alu_src1_r  ),
+    .s_axis_dividend_tvalid (sdiv_dend_valid),
+    .s_axis_dividend_tready (sdiv_dend_ready),
+    .m_axis_dout_tdata      (sdiv_result  ),
+    .m_axis_dout_tvalid     (sdiv_out_valid)
+    );
+
+div_gen_unsigned u_div_gen_unsigned(// 进行无符号除法运算
+    .aclk                   (clk         ),
+    .s_axis_divisor_tdata   (alu_src2_r  ),
+    .s_axis_divisor_tvalid  (udiv_sor_valid),
+    .s_axis_divisor_tready  (udiv_sor_ready),
+    .s_axis_dividend_tdata  (alu_src1_r  ),
+    .s_axis_dividend_tvalid (udiv_dend_valid),
+    .s_axis_dividend_tready (udiv_dend_ready),
+    .m_axis_dout_tdata      (udiv_result  ),
+    .m_axis_dout_tvalid     (udiv_out_valid)
+    );
+
+assign EX_final_result =  div_signed_r ? (get_div_or_mod_r ? sdiv_result[63:32] : sdiv_result[31:0]):
+                          div_unsigned_r ? (get_div_or_mod_r ? udiv_result[63:32] : udiv_result[31:0]):
+                          alu_result;
+assign data_sram_addr_EX  = EX_final_result;//设计访存地址
+
+//将一些后续控制信号从EX传递下去
+always @(posedge clk) begin//访存控制
     if(reset) begin
         data_sram_en_MEM <= 1'b0;
         data_sram_we_MEM <= 4'b0;
@@ -524,19 +671,75 @@ always @(posedge clk) begin
         data_sram_wdata_MEM <= data_sram_wdata_EX;
     end
 end
+always @(posedge clk) begin//寄存器控制
+    if(reset) begin
+        res_from_mem_MEM <= 1'b0;
+        dest_MEM <= 5'd0;
+        gr_we_MEM <= 1'b0;
+    end
+    else if(EX_allowin && ID_valid && ID_readygo) begin
+        res_from_mem_MEM <= res_from_mem_EX;
+        dest_MEM <= dest_EX;
+        gr_we_MEM <= gr_we_EX;
+    end
+end
+/****************************************************************************/
+
+
+
+//EX --> MEM
+
+// data_sram_en_MEM, data_sram_we_MEM, data_sram_addr_MEM, data_sram_wdata_MEM      访存相关信号
+// res_from_mem_MEM, dest_MEM, gr_we_MEM      寄存器相关信号
+// PC_MEM
 
-//将数据以及控制信号均改为流动到该级的数据与信号
+
+
+//MEM流水级
+/****************************************************************************/
+//设置访存信号
 assign data_sram_en = data_sram_en_MEM;
 assign data_sram_we = data_sram_we_MEM;
 assign data_sram_addr = data_sram_addr_MEM;
 assign data_sram_wdata = data_sram_wdata_MEM;
 
+//将一些后续控制信号从MEM传递下去
+always @(posedge clk) begin
+    if(reset) begin
+        alu_result_WB <= 32'h0;
+        res_from_mem_WB <= 1'b0;
+        dest_WB <= 5'd0;
+        gr_we_WB <= 1'b0;
+    end
+    else if(MEM_allowin && EX_valid && EX_readygo) begin
+        alu_result_WB <= data_sram_addr_MEM;
+        res_from_mem_WB <= res_from_mem_MEM;
+        dest_WB <= dest_MEM;
+        gr_we_WB <= gr_we_MEM;
+    end
+end
+
 assign mem_result   = data_sram_rdata;
-assign final_result = res_from_mem_WB ? mem_result : alu_result_WB;
+/****************************************************************************/
+
+
+
+//MEM --> WB
+
+// res_from_mem_WB, dest_WB, gr_we_WB      寄存器相关信号
+// mem_result, alu_result_WB      访存及寄存器结果
+// PC_WB
+
+
+//WB流水级
+/****************************************************************************/
+assign final_result = res_from_mem_WB ? mem_result : alu_result_WB; // 最终写回数据
 
 assign rf_we    = gr_we_WB && MEM_valid && MEM_readygo;
 assign rf_waddr = dest_WB;
 assign rf_wdata = final_result;
+/****************************************************************************/
+
 
 // debug info generate
 assign debug_wb_pc       = pc_WB;
@@ -544,4 +747,5 @@ assign debug_wb_rf_we   = {4{rf_we}};
 assign debug_wb_rf_wnum  = dest_WB;
 assign debug_wb_rf_wdata = final_result;
 
+
 endmodule
\ No newline at end of file
-- 
2.44.0.windows.1

